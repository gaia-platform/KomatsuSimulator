
/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

#include "gaia/logger.hpp"

#include "gaia_danger_zone.h"
#include "danger_zone.hpp"
#include "zones.hpp"

#define DirectionZoneCodeDefault 6

// Set these to what you want to log, add or subtract at will.
std::vector<std::string> topics{"/image", "/lidar"};

// Set this to an existing directory + desired log name.
std::string log_file_base_name = "~/logs/retrolog";

const int c_log_seconds_past = 5;
const int c_log_seconds_forward = 25;

using namespace gaia::danger_zone;

ruleset objects_detection
{
    on_insert(detection)
    {
        std::shared_ptr<obstacles_t> obstacles = obstacles_t::new_instance();

        for (detection->obj:d_object)
        {
            // Sets the zone using the distance from the sensor to the detected object.
            // pos_y represent the vertical offset, so we need to use pos_x and pos_z for calculations.
            obj.zone_id = zones_t::get_range_zone_id(obj.pos_x, obj.pos_z);

            // Find the direction of the object relative to the sensor.
            uint8_t direction_zone = DirectionZoneCodeDefault;

            // Create a message for each obstacle.
            // TODO: the first argument is the class_id and is currently not used
            //  by the simulation. Putting a placeholder for now.
            obstacles->add(
                "_", obj.zone_id, direction_zone,
                obj.pos_x, obj.pos_y, obj.pos_z,
                obj.size_x, obj.size_y, obj.size_z,
                obj.orient_x, obj.orient_y, obj.orient_z, obj.orient_w);
        }

        // Now that all obstacle messages have been collected, we can send them.
        danger_zone_t::get_instance()->send_obstacle_array_message(
            obstacles,
            detection.frame_id, detection.seconds, detection.nseconds);
    }

    on_update(d_object.zone_id)
    {
        // Find the object corresponding to the detection.
        auto obj = object_t::list()
                   .where(object_expr::id == d_object.object_id)
                   .begin();

        // If its zone changed, create a zone transition event.
        if (obj->zone_id() != d_object.zone_id)
        {
            zone_transition_event.insert(
                object_id: obj->id(),
                from_zone_id: obj->zone_id(),
                to_zone_id: d_object.zone_id);
        }
    }
}

/**
 * This ruleset handles the transition of an object from one zone to
 * another. The ruleset is marked as serial_group() to make the
 * rules within it run serially. This avoids transaction conflicts
 * when adding/removing objects from the zone table.
 */
ruleset zone_transition : serial_group()
{
    on_insert(event:zone_transition_event)
    {
        auto obj = object_t::list()
            .where(object_expr::id == event.object_id)
            .begin();

        gaia_log::app().info(
            "Object:{} transitioning from zone:{} to zone:{}",
            event.object_id,
            zones_t::zone_id_str(event.from_zone_id),
            zones_t::zone_id_str(event.to_zone_id));

        object_writer obj_w = obj->writer();
        obj_w.zone_id = event.to_zone_id;
        obj_w.update_row();

        // TODO: Need to add logic to check whether logging was already being done.
        if (strcmp(obj->class_id(), "Person") == 0)
        {
            if (event.from_zone_id == zones_t::c_green_zone
                && event.to_zone_id != zones_t::c_no_zone)
            {
                danger_zone_t::get_instance()->trigger_log(
                    c_log_seconds_past, c_log_seconds_forward, log_file_base_name, topics);
            }
        }
        else if (event.to_zone_id == zones_t::c_red_zone)
        {
            danger_zone_t::get_instance()->trigger_log(
                c_log_seconds_past, c_log_seconds_forward, log_file_base_name, topics);
        }
    }
}
