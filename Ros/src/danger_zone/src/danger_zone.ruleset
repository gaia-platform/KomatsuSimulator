
/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

#include <cmath>

#include "gaia/logger.hpp"

#include "danger_zone.hpp"
#include "zones.hpp"

#define DirectionZoneCodeDefault 6

// Set these to what you want to log, add or subtract at will.
std::vector<std::string> topics{"/image", "/lidar"};

// Set this to an existing directory + desired log name.
std::string log_file_base_name = "~/logs/retrolog";

const int c_log_seconds_past = 5;
const int c_log_seconds_forward = 25;

ruleset danger_zone_ruleset
{
    on_insert(detection)
    {
        std::shared_ptr<obstacles_t> obstacles = obstacles_t::new_instance();

        for (detection->obj:d_object)
        {
            // Sets the zone using the distance from the sensor to the detected object.
            // TODO: unclear why pos_z works better than pos_y (this is how it was at the beginning).s
            obj.zone = zones_t::get_range_zone_id(obj.pos_x, obj.pos_z);

            gaia_log::app().info("Object:{} dist:{} zone:{}", obj.object_id, std::sqrt(obj.pos_x * obj.pos_x + obj.pos_y * obj.pos_y), obj.zone);

            // Find the direction of the object relative to the sensor.
            uint8_t direction_zone = DirectionZoneCodeDefault;

            // Create a message for each obstacle.
            // TODO: the first argument is the class_id and is currently not used
            //  by the simulation. Putting a placeholder for now.
            obstacles->add(
                "placeholder", obj.zone, direction_zone,
                obj.pos_x, obj.pos_y, obj.pos_z,
                obj.size_x, obj.size_y, obj.size_z,
                obj.orient_x, obj.orient_y, obj.orient_z, obj.orient_w);

            // Trigger a logging event.
//            if ( obj.zone == zones_t::c_red_zone)
//            {
//                danger_zone_t::get_instance()->trigger_log(
//                    c_log_seconds_past, c_log_seconds_forward, log_file_base_name, topics);
//            }
        }

        // Now that all obstacle messages have been collected, we can send them.
        danger_zone_t::get_instance()->send_obstacle_array_message(
            obstacles,
            detection.frame_id, detection.seconds, detection.nseconds);
    }

    on_update(d_object.zone)
    {
//         gaia_log::app().info("Object {} is in zone {}", d_object.object_id, d_object.zone);
    }
}
